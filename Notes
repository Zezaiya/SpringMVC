SpringMVC
概述:与servlet技术功能等同,都属于web层开发技术,不过它可以极大简化前者的代码(表现层开发框架)
优点:开发简洁,灵活性强

准备环境:1.导入spring-webmvc坐标和servlet坐标
        2.创建SpringMVC控制类,并在该类上写上@Controller,代替servlet(里面可以定义方法,方法体内定义返回值,即返回给浏览器的内容)
        3.创建SpringMVC配置类加载需要的bean
        4.初始化Servlet容器,加载SpringMVC环境,设置SpringMVC技术处理的请求

总结:有许多配置只需要我们添加一次,后期需要我们做的事情很少

一次性工作:
         ->创建工程,设置tomcat服务器
         ->导入坐标
         ->创建ServletContainerInitConfig容器启动类以及里面重写的方法
         ->创建SpringMVC核心配置类(@Configure,@ComponentScan)

多次工作:
         ->创建对应需求的controller控制器
         ->在controller里编写需要的servlet(方法,在方法上写上对应的访问路径[@ResultMapping]和返回体类型[@ResponseBody])


启动服务器初始化过程
1.服务器启动，执行ServletContainersInitConfig类，初始化web容器
2.执行createServletApplicationContext方法，创建了webApplicationContext对象
3.加载SpringMvcConfig
4.执行@Componentscan加载对应的bean
5.加载UserController，每个@RequestMapping的名称对应一个具体的方法
6.执行getServletMappings方法，定义所有的请求都通过SpringMVC

单次请求过程
1.发送请求localhost/ save
2.web容器发现所有请求都经过SpringMVC，将请求交给SpringMVC处理
3.解析请求路径/save
4.由/save匹配执行对应的方法save(）
5.执行save(）
6.检测到有@ResponseBody直接将save()方法的返回值作为响应体返回给请求方

实际开发遇到的问题:SpringMVC所需要加载的包仅是controller,但是还有service和dao的包仍需要由Spring加载,如何不让Spring错误地加载到controller包?

解决方案:在SpringConfig配置类的包扫描器里排除controller这个包(或者精准到dao和service包)


1、DispatcherServlet是什么
DispatcherServlet是Spring MVC最核心的类，是前端控制器（Front Controller）设计模式的实现，正是这个核心组件接收所有传输到Web应用的HTTP请求。

2、DispatcherServlet的作用
把一个HTTP request交给它真正的处理方法
解析HTTP request的header和body中的数据，并把它们转换为DTO(数据传输对象)
Model-View-Controller三方的交互
再把业务逻辑返回的DTO转换成HTTP response
渲染具体的视图等
-------------------------------------------------------------------------------------------------------------------------
请求路径映射
问题:当不同的controller里出现了相同的路径名时,程序无法运行(因为无法判断你想访问的是哪个servlet)
->解决方式:加上模块名

问题:如果在每一个servlet上面都加上模块名过于繁琐
->解决方式:在该controller类上main添加@ResultMapping()注解,表示该类的mapping均配上该前缀
-------------------------------------------------------------------------------------------------------------------------
获取请求的请求参数
Get/Post请求:只需要在对应路径的servlet方法形参里写上需要获取的参数
   对于普通参数(英文数字)可以直接传入
   对于中文,需要在容器加载类里添加过滤器(重写过滤器方法)
如果传入的参数名和servlet方法的形参名不一致,会导致无法传入,这时我们需要在形参前添加@RequestParam("里面写上传入参数的名称"->映射)

->优化:其实我们可以创建一个实体类,在实体类中定义成员变量,将该实体类作为形式参数来接收数据

不同参数传入:
数组:我们将数组作为形式参数时,MVC会自动将请求内和形参数组名相同的值传入数组
集合:如果直接将集合作为形参,MVC会创造集合的对象(MVC对于引用类型参数时的处理方式,创建对象->set方法赋值),但集合不能创建对象,所以我们需要加上
    @RequestParam注解,表示将表里的数据作为值直接传入List集合

@RequestParam->GET请求    @RequestBody->POST请求
-------------------------------------------------------------------------------------------------------------------------
对于企业开发,参数的传入一般是json格式
使用方法:1.导入坐标   2.在MVC核心配置类里加上@EnableWebMvc注释(功能很多),可以实现由Json格式转化为对应类型参数   3.使用@RequestBody注解即可

注意:一般来说,现在都用json传参,所以@RequestBody使用较多,对于@RequestParam是针对非json的表单等路径,需了解
-------------------------------------------------------------------------------------------------------------------------
对于特殊的参数(Date时间格式的数据)可以直接传入
注意:需要传入的日期格式默认为:2023/3/22  斜线形式
->如果需要修改,则需要在日期形参的前面添加@DateTimeFormat(pattern="yyyy-MM-dd") "-"即为我们想传入的格式
-------------------------------------------------------------------------------------------------------------------------
响应
->如果我们想要返回一个页面,我们可以直接在servlet里return "页面的名字"      //不加@Response注解
->如果我们想要返回json类型的数据,我们只需要直接return+名字就行了           //加@Response注解

   //@Response注解的作用就是将你写在return后面的数据转换成该servlet的返回值类型,真正将字符串转换成json格式的是jackson的类
      HttpMessageConverter接口完成的,不加该注解可以实现页面跳转
-------------------------------------------------------------------------------------------------------------------------
REST风格->表现形式状态转换
概念:通俗一点就是改变我们传统写网址访问资源的格式

GET
传统格式:http://localhost/user/getById?id=1
REST格式:http://localhost/user/1

POST
传统格式:http://localhost/user/saveUser
REST格式:http://localhost/user

作用:1.隐藏资源的访问行为,无法通过地址得知资源在做何种操作
     2.简化书写

注意:既然是风格不是规范,说明是可以不遵守的,但是如今随着越来越多的公司使用,渐渐成为了一种约定

实现的思想:通过在servlet里定义不同的请求方式,达到相同的路径名可以访问到不同的servlet    增(Post)  删(Delete)  查(get)  改(put)
具体实现:
      1.如果controller类里全部都需要用@ResponsBody只需要统一使用@RestController即可代替(@controller和@ResponsBody)
      2.如果需要修改请求方式,只需要在对应的Servlet上添加GetMapping(例)即可,同时,如果该类都是对应同一个路径,直接在类上添加@RequestMapping("路径名")
      3.如果要传入参数,只需要在对应的Mapping("/{参数名}"),同时在参数前添加@PathVariable标签

-------------------------------------------------------------------------------------------------------------------------
表现层与前端数据传输协议
问题:后端通过json传来的代码格式不一,前端需要遍历等繁琐的操作才能获取到对应的信息
解决方法:统一格式

原来的格式:(查询单条数据)                                            现在的格式:
{                                                            {
    "data":{                                                    "code":20041
          "id":1,                                               "data":{
          "type":"计算机理论",                                           "id":1,
          "name":"计算机组成原理"                                       "type":"计算机理论",
    }                                                                 "name":"计算机组成原理"
}                                                                   }
                                                              }